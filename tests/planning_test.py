"""
Unit tests for the planning agent.
"""

import json
import sys
import tempfile
from pathlib import Path
from unittest.mock import Mock, patch

import pytest

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from agents.planning.models import Milestone, PlanningOutput, Task
from agents.planning.planner import ProjectPlanner


class TestProjectPlanner:
    """Test the ProjectPlanner class."""

    def setup_method(self):
        """Setup test fixtures."""
        self.temp_dir = tempfile.mkdtemp()
        self.planner = ProjectPlanner(output_dir=self.temp_dir)

        # Sample specification
        self.sample_spec = {
            "title": "Test E-Commerce Platform",
            "summary": "A modern e-commerce platform for online retail",
            "features": [
                {"name": "User Authentication", "desc": "Login and registration system"},
                {"name": "Product Catalog", "desc": "Browse and search products"},
                {"name": "Shopping Cart", "desc": "Add items and checkout"},
            ],
            "constraints": ["Must support 1000+ users", "Mobile responsive"],
            "metadata": {"tech_stack": ["React", "Node.js"], "timeline": "8 weeks"},
        }

    def test_load_specification(self):
        """Test loading specification from JSON file."""
        # Create temporary spec file
        spec_file = Path(self.temp_dir) / "test_spec.json"
        with open(spec_file, "w") as f:
            json.dump(self.sample_spec, f)

        # Load specification
        loaded_spec = self.planner.load_specification(str(spec_file))

        assert loaded_spec["title"] == "Test E-Commerce Platform"
        assert len(loaded_spec["features"]) == 3
        assert "User Authentication" in [f["name"] for f in loaded_spec["features"]]

    def test_generate_plan_fallback(self):
        """Test plan generation with fallback method."""
        # Disable LLM for fallback testing
        self.planner.primary_llm = None
        self.planner.fallback_llm = None

        plan = self.planner.generate_plan(self.sample_spec)

        assert isinstance(plan, PlanningOutput)
        assert plan.project_title == "Test E-Commerce Platform"
        assert len(plan.milestones) <= 5
        assert len(plan.milestones) > 0
        assert plan.tech_stack  # Should have some tech stack
        assert plan.estimated_total_duration

        # Verify milestone structure
        first_milestone = plan.milestones[0]
        assert first_milestone.name
        assert first_milestone.description
        assert len(first_milestone.tasks) > 0

        # Verify task structure
        first_task = first_milestone.tasks[0]
        assert first_task.name
        assert first_task.description

    def test_save_planning_output(self):
        """Test saving planning output to disk."""
        plan = PlanningOutput(
            project_title="Test Project",
            project_summary="Test summary",
            milestones=[
                Milestone(
                    name="Setup",
                    description="Project setup",
                    estimated_duration="1 week",
                    tasks=[
                        Task(
                            name="Init repo",
                            description="Initialize repository",
                            estimated_hours=4,
                            dependencies=[],
                        )
                    ],
                )
            ],
            tech_stack=["React", "Node.js"],
            open_questions=["What database to use?"],
            estimated_total_duration="4 weeks",
        )

        session_dir = self.planner.save_planning_output(plan)

        # Verify files were created
        session_path = Path(session_dir)
        assert session_path.exists()
        assert (session_path / "planning_output.json").exists()
        assert (session_path / "README.md").exists()

        # Verify JSON content
        with open(session_path / "planning_output.json") as f:
            saved_plan = json.load(f)

        assert saved_plan["project_title"] == "Test Project"
        assert len(saved_plan["milestones"]) == 1
        assert saved_plan["tech_stack"] == ["React", "Node.js"]

    @patch("agents.planning.planner.ChatBedrock")
    def test_llm_integration(self, mock_bedrock):
        """Test LLM integration for plan generation."""
        # Mock LLM response
        mock_response = Mock()
        mock_response.content = json.dumps(
            {
                "project_title": "LLM Generated Project",
                "project_summary": "Generated by LLM",
                "milestones": [
                    {
                        "name": "Phase 1",
                        "description": "Initial development",
                        "estimated_duration": "2 weeks",
                        "tasks": [
                            {
                                "name": "Setup",
                                "description": "Project setup",
                                "estimated_hours": 8,
                                "dependencies": [],
                            }
                        ],
                    }
                ],
                "tech_stack": ["Python", "FastAPI"],
                "open_questions": ["Deployment platform?"],
                "estimated_total_duration": "6 weeks",
            }
        )

        mock_llm = Mock()
        mock_llm.invoke.return_value = mock_response
        mock_llm.__class__.__name__ = "ChatBedrock"

        # Setup planner with mocked LLM
        planner = ProjectPlanner(output_dir=self.temp_dir)
        planner.primary_llm = mock_llm

        plan = planner.generate_plan(self.sample_spec)

        assert plan.project_title == "LLM Generated Project"
        assert plan.tech_stack == ["Python", "FastAPI"]
        assert len(plan.open_questions) == 1
        mock_llm.invoke.assert_called_once()

    def test_planning_output_validation(self):
        """Test Pydantic validation for planning output."""
        # Valid planning output
        valid_plan = {
            "project_title": "Valid Project",
            "project_summary": "Valid summary",
            "milestones": [
                {
                    "name": "Milestone 1",
                    "description": "First milestone",
                    "tasks": [
                        {
                            "name": "Task 1",
                            "description": "First task",
                            "estimated_hours": 8,
                            "dependencies": [],
                        }
                    ],
                }
            ],
            "tech_stack": ["React"],
            "open_questions": [],
        }

        plan = PlanningOutput(**valid_plan)
        assert plan.project_title == "Valid Project"
        assert len(plan.milestones) == 1

        # Test validation error for too many milestones
        invalid_plan = valid_plan.copy()
        invalid_plan["milestones"] = [valid_plan["milestones"][0]] * 6  # 6 milestones (max is 5)

        with pytest.raises(ValueError):
            PlanningOutput(**invalid_plan)

    def test_end_to_end_planning(self):
        """Test complete planning workflow."""
        # Create spec file
        spec_file = Path(self.temp_dir) / "spec.json"
        with open(spec_file, "w") as f:
            json.dump(self.sample_spec, f)

        # Disable LLM for predictable testing
        self.planner.primary_llm = None
        self.planner.fallback_llm = None

        # Run complete planning workflow
        session_dir = self.planner.plan_project(str(spec_file))

        # Verify output
        session_path = Path(session_dir)
        assert session_path.exists()

        # Load and verify planning output
        with open(session_path / "planning_output.json") as f:
            plan_data = json.load(f)

        plan = PlanningOutput(**plan_data)
        assert plan.project_title == "Test E-Commerce Platform"
        assert len(plan.milestones) <= 5
        assert plan.tech_stack

        # Verify README was generated
        readme_path = session_path / "README.md"
        assert readme_path.exists()

        readme_content = readme_path.read_text()
        assert "Test E-Commerce Platform" in readme_content
        assert "Milestones" in readme_content
